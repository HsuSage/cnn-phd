nSize = 3
testSize = 7
nnSize = 3

camN0 = createZNeuron 3 3
camN1 = createZNeuron 3 3
camN2 = createZNeuron 3 3

nn = [camN0, camN1, camN2]
baseLst = [0, 2, 4, 6, 1, 3, 5, 7]
baseOLst = [0, 6, 7, 3, 2, 4, 2, 1]
hiddenLst = P.map (reverse . num2Bin' 2) [0]

inputLst = P.map (reverse . num2Bin' nSize) baseLst
outputLst = P.map (reverse . num2Bin' nSize) baseOLst
inputs = P.map (fromListUnboxed (ix1 nSize)) inputLst
outputs = P.map (fromListUnboxed (ix1 nSize)) outputLst
hidden = P.map (fromListUnboxed (ix1 2)) hiddenLst
trainSet = P.zipWith (\x y -> TrainElem x y) inputs outputs

updates = updatesWithConditions (length nn) (length trainSet) 0

-- trainUntilLearned nn trainSet 0 8

ff x = do print x; return $ trainNeurons (trainSet !! x) (updates !! x) nn
mapM ff [0 .. 1]

(TrainElem train desired) = trainSet !! 5
(CAMUpdate lIndex cElem) = updates !! 5

(query, wAo) = queryNeuronsAcc nn train -- wAo = Weights and Outputs
compared = vecCompare query desired
chosenNeuron = nn !! lIndex
wAoI = wAo !! lIndex
deltaPos = take (length nn - lIndex) $ reverse wAo
deltaP = calculateDelta deltaPos compared
----

ddW0 = deltaWeights' (deltaPos !! 0) compared
wtD0 = weightsToDelta ddW0
ddW1 = deltaWeights' (deltaPos !! 1) wtD0
wtD1 = weightsToDelta ddW1
ddW2 = deltaWeights' (deltaPos !! 2) wtD1
wtD2 = weightsToDelta ddW2

nSize = 2
camN0 = createZNeuron 2 2
nn = [camN0, camN0]
baseLst = [0, 1, 2, 3]
baseOLst = [0, 3, 3, 0]
inputLst = P.map (reverse . num2Bin' nSize) baseLst
outputLst = P.map (reverse . num2Bin' nSize) baseOLst
inputs = P.map (fromListUnboxed (ix1 nSize)) inputLst
outputs = P.map (fromListUnboxed (ix1 nSize)) outputLst
trainSet = P.zipWith (\x y -> TrainElem x y) inputs outputs
updates = updatesWithConditions (length nn) (length trainSet) 0
-- trainUntilLearned nn trainSet 0 0

trainCAMNN nn updates trainSet

nn1 = trainNeurons (trainSet !! 1) (updates !! 1) nn
nn2 = trainNeurons (trainSet !! 2) (updates !! 2) nn1
nn3 = trainNeurons (trainSet !! 3) (updates !! 3) nn2

tI = trainInput $ trainSet !! 2
h1 = applyNeuron tI (nn3 !! 0)
o1 = applyNeuron h1 (nn3 !! 1)

camW = camWeights (nn3 !! 1)
camT = camThresholds (nn3 !! 1)
-- camW = CAMWElem (fromListUnboxed (ix2 2 2) [True, False, True, False]) 0
collision = layerColide camW h1 xor
summ = layerSummation collision
res = layerOperation summ camT (>=)

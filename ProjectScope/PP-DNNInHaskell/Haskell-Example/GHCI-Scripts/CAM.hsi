gen = mkStdGen 2

camW0 = fromListUnboxed (ix2 2 2) [False, False, False, False]
camT0 = fromListUnboxed (ix1 2) [2, 2] :: NTTVU
camN0 = CAMNeuron (CAMWElem camW0 0) (CAMTElem camT0 0)

camW1 = fromListUnboxed (ix2 2 2) [False, False, False, False]
camT1 = fromListUnboxed (ix1 2) [2,1] :: NTTVU
camN1 = CAMNeuron (CAMWElem camW1 0) (CAMTElem camT1 0)

camW2 = fromListUnboxed (ix2 2 2) [True, False, True, False]
camT2 = fromListUnboxed (ix1 2) [2,2] :: NTTVU
camN2 = CAMNeuron (CAMWElem camW2 0) (CAMTElem camT2 0)

sel0 = fromListUnboxed (ix1 2) [True, False]

input0 = fromListUnboxed (ix1 2) [False, False]
output0 = fromListUnboxed (ix1 2) [False, False]
input1 = fromListUnboxed (ix1 2) [False, True]
output1 = fromListUnboxed (ix1 2) [True, True]
input2 = fromListUnboxed (ix1 2) [True, False]
output2 = fromListUnboxed (ix1 2) [True, True]
input3 = fromListUnboxed (ix1 2) [True, True]
output3 = fromListUnboxed (ix1 2) [False, False]

inputs = [input0, input1, input2, input3]
outputs = [output0, output1, output2, output3]
trainSet = P.zipWith (\x y -> TrainElem x y) inputs outputs

nn = [camN0, camN0]
updatesLst = [(1, 0, CAMThreshold), (1, 0, CAMWeight), (0, 1, CAMThreshold), (0, 0, CAMWeight)]
updates = P.map (\(x, y, z) -> CAMUpdate x y z) updatesLst
updates = take (length trainSet) $ constructUpdate' (length nn)

nn' = trainNeurons' (trainSet !! 1) (updates !! 1) nn
nn'' = trainNeurons' (trainSet !! 2) (updates !! 2) nn'

trainCAMNN' nn updates trainSet
trainUntilLearned' nn trainSet 0 3

nSize = 4
testSize = 4
nnSize = 3

camN0 = createZNeuron 2 3
camN1 = createZNeuron 3 2
camN2 = createZNeuron 4 3

baseLst = [1 .. testSize]
baseOLst = P.map sin [1 .. testSize]
inputsLst = P.map (num2Bin' nSize) baseLst
outputLst = P.map (num2Bin' nSize . round . (* 100)) baseOLst
inputs = P.map (fromListUnboxed (ix1 nSize)) inputsLst
outputs = P.map (fromListUnboxed (ix1 nSize)) outputLst

trainSet = P.zipWith (\x y -> TrainElem x y) inputs outputs

nn = replicate nnSize camN0
updates = take (length trainSet) $ constructUpdate (length nn)

trainNeurons (trainSet !! 0) (updates !! 0) nn

trainUntilLearned nn trainSet 0 3

train = trainInput $ trainSet !! 0
desired = trainOutput $ trainSet !! 0
lIndex = lstIndex $ updates !! 0
cElem = camElem $ updates !! 0

query = foldl applyNeuron train nn
compared = vecCompare query desired
chosenNeuron = nn !! lIndex
choppedNNR = take (lIndex + 1) $ reverse nn
choppedNN = take (lIndex + 1) nn
hidden = foldl applyNeuron train choppedNN
output = applyNeuron hidden chosenNeuron
deltaP = foldl applyReverseNeuron' compared choppedNNR
camNN = updateCAMNeuron' chosenNeuron cElem deltaP output hidden
nn' = replaceElem nn lIndex camNN


camW1 = fromListUnboxed (ix2 3 2) [True, False, False, True, False, False]
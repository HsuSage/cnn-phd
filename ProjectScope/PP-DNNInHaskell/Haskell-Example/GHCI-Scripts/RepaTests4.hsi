import qualified Data.Array.Repa as RP
let x = 3 :: InputNodes
let y = 3 :: OutputNodes
let x' = fromIntegral x
let y' = fromIntegral y
let shape = Z :. x :. y
let ssh = Z :. x

let stdRand = mkStdGen 8
let listedWIH = take (x' * y') $ (randoms stdRand :: [Bool])
let wihNN = fromListUnboxed shape listedWIH

stdRand <- newStdGen
let listedWHO = take (x' * y') $ (randoms stdRand :: [Bool])
let whoNN = fromListUnboxed shape listedWHO
let nnR = NeuralNetwork True wihNN whoNN

stdRand <- newStdGen
let listedInput = take (x') $ (randoms stdRand :: [Bool])
let inputs = fromListUnboxed ssh listedInput

stdRand <- newStdGen
let listedInput = take (x') $ (randoms stdRand :: [Bool])
let training = fromListUnboxed ssh listedInput

(NeuralNetwork lRateNN wihNN whoNN) = nnR

-- matVecDense wihNN toInput
-- applySHY f h sh@(Z :. x :. y) = f sh * h (Z :. y)
-- let mm = traverse2 wihNN toInput const applySHY




----------------------------------------------------------------------
trainCSV <- readCSVFile "../MNIST-Data/mnist_train-100.csv"
testCSV <- readCSVFile "../MNIST-Data/mnist_test-10.csv"

(nnBase, epochs) <- readElems ["5","True","4"] inputNodes outputNodes
nn <- createNNR nnBase

-- trainedNN <- foldrM trainNN nn trainCSV

(MImg _ training inputs) = trainCSV !! 0
(NeuralNetwork lRateNN wihNN whoNN) = nn
trainedNN <- analyzeLines epochs nn trainCSV
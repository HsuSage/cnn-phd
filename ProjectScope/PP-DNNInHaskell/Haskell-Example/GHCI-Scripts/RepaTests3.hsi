import qualified Data.Array.Repa                      as RP
import qualified Data.Array.Repa.Algorithms.Matrix as RP
let x = 6 :: InputNodes
let y = 8 :: OutputNodes
let shape = Z :. x :. y
let ssh = Z :. y

let wihNN = fromListUnboxed shape [1..48]
let whoNN = fromListUnboxed shape [1..6]
let nnR = NeuralNetworkR 0.1 wihNN whoNN

fLayer = fromListUnboxed ssh [1 .. 8]

llk <- computeP $ backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer :: IO NNLayerR
llp <- computeP $ extend (Any :. x :. All) fLayer :: IO NNLayerR

lpo <- wihNN *^ llk
lop <- computeP $ wihNN *^ llp :: IO NNLayerR

sumP lpo
sumP lop

matVecDense wihNN fLayer



------------------------------------------------------------

import qualified Data.Array.Repa                      as RP
import qualified Data.Array.Repa.Algorithms.Matrix as RP

let x = 3 :: InputNodes
let y = 3 :: OutputNodes

let ssh = Z :. y

fLayer1 = fromListUnboxed ssh [1 .. 3]
fLayer2 = fromListUnboxed ssh [5,2,3]

outerProd fLayer1 fLayer2



------------------------------------------------------------

import qualified Data.Array.Repa                      as RP
import qualified Data.Array.Repa.Algorithms.Matrix as RP

let x = 3 :: InputNodes
let y = 10 :: OutputNodes

let ssh = Z :. y

fLayer1 = fromListUnboxed ssh [1 .. 10]
fLayer2 = fromListUnboxed ssh [10 .. 19]

traverse fLayer1 DIM0

let xp = fromListUnboxed (Z :. (3::Int) :. (3::Int) :. (3::Int)) [1..27] :: Array U DIM3 Int
computeP $ traverse x id (\_ (Z :. i :. j :. k) -> i) :: IO (Array U DIM3 Int)
let x = 3 :: InputNodes
let y = 3 :: OutputNodes
let x' = fromIntegral x
let y' = fromIntegral y
let shape = Z :. x :. y
let ssh = Z :. x

let wihNN = fromListUnboxed shape [0 .. (x' * y' - 1.0)]
let whoNN = fromListUnboxed shape [(x' * y') .. (2 * x' * y' - 1)]
let nnR = NeuralNetworkR 0.1 wihNN whoNN

fLayer <- computeP $ slice (wihR nnR) (Any :. (2::Int)) :: IO NLayerR
let ffLayer = slice (wihR nnR) (Any :. (2::Int))
hLayer <- computeP $ slice (wihR nnR) (Any :. (1::Int)) :: IO NLayerR
oLayer <- computeP $ slice (whoR nnR) (Any :. (0::Int)) :: IO NLayerR

llk <- computeP $ backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer :: IO NNLayerR
llp <- computeP $ extend (Any :. x :. All) fLayer :: IO NNLayerR

lpo <- mmultP wihNN llk
lop <- mmultP wihNN llp

sumP lpo
sumP lop


foldP (+) 0 lop

zipWith (*) wihNN fLayer

let x = fromListUnboxed (Z :. (5 :: Int) :. (2 :: Int)) [1..10]
computeP $ reshape (Z :. (2::Int) :. (5::Int)) x :: IO (Array U DIM2 Double)

traverse2 wihNN fLayer (\_ y ->  y) (\f h sh -> h sh)

let applySHX f h sh@(Z :. x :. y) = (f sh) * (h (Z :. x))
let applySHY f h sh@(Z :. x :. y) = (f sh) * (h (Z :. y))
computeP $ traverse2 wihNN fLayer (\x _ -> x) applySHX :: IO NNLayerR
computeP $ traverse2 wihNN fLayer (\x _ -> x) applySHY :: IO NNLayerR

let applySX f h sh@(Z :. x :. y) = (f sh) * (h (Z :. x))
let applySY f h sh@(Z :. x :. y) = (f sh) * (h (Z :. y))
computeP $ traverse2 wihNN fLayer (\x _ -> x) applySHX :: IO NNLayerR
computeP $ traverse2 wihNN fLayer (\x _ -> x) applySHY :: IO NNLayerR

computeP $ traverse2 wihNN fLayer (\x _ -> x) (\f h sh -> f sh) :: IO NNLayerR
computeP $ traverse2 wihNN fLayer (\_ y ->  y) (\f h sh -> h sh) :: IO NLayerR


extend (Any :. (3::Int) :. All) fLayer
computeP $ extend (Any :. (3::Int) :. All) fLayer :: IO NNLayer
extend shape fLayer


backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer
llk <- computeP $ backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer :: IO NNLayerR

extend (Any :. x :. All) fLayer
llp <- computeP $ extend (Any :. x :. All) fLayer :: IO NNLayerR


let xx = fromListUnboxed (Z :. (3::Int) :. (3::Int)) [1..9]
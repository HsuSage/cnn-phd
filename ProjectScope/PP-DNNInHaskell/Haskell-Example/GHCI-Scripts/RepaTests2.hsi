import qualified Data.Array.Repa                      as RP
import qualified Data.Array.Repa.Algorithms.Matrix as RP
let x = 3 :: InputNodes
let y = 3 :: OutputNodes
let shape = Z :. x :. y
let ssh = Z :. x

let wihNN = fromListUnboxed shape [0..8]
let whoNN = fromListUnboxed shape [9..17]
let nnR = NeuralNetworkR 0.1 wihNN whoNN

fLayer <- computeP $ slice (wihR nnR) (Any :. (2::Int)) :: IO NLayerR
let ffLayer = slice (wihR nnR) (Any :. (2::Int))
hLayer <- computeP $ slice (wihR nnR) (Any :. (1::Int)) :: IO NLayerR
oLayer <- computeP $ slice (whoR nnR) (Any :. (0::Int)) :: IO NLayerR

llk <- computeP $ backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer :: IO NNLayerR
llp <- computeP $ extend (Any :. x :. All) fLayer :: IO NNLayerR

lpo <- mmultP wihNN llk
lop <- mmultP wihNN llp

sumP lpo
sumP lop


foldP (+) 0 lop

zipWith (*) wihNN fLayer

let x = fromListUnboxed (Z :. (5 :: Int) :. (2 :: Int)) [1..10]
computeP $ reshape (Z :. (2::Int) :. (5::Int)) x :: IO (Array U DIM2 Double)

traverse2 wihNN fLayer (\_ y ->  y) (\f h sh -> h sh)
computeP $ traverse2 wihNN fLayer (\_ y ->  y) (\f h sh -> h sh) :: IO NLayerR


extend (Any :. (3::Int) :. All) fLayer
computeP $ extend (Any :. (3::Int) :. All) fLayer :: IO NNLayer
extend shape fLayer


backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer
llk <- computeP $ backpermute shape (\e@(Z :. x :. y) -> Z :. x) fLayer :: IO NNLayerR

extend (Any :. x :. All) fLayer
llp <- computeP $ extend (Any :. x :. All) fLayer :: IO NNLayerR


let xx = fromListUnboxed (Z :. (3::Int) :. (3::Int)) [1..9]
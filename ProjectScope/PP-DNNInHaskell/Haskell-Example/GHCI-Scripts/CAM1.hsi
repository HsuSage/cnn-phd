gen = mkStdGen 5

nn' = foldr (\(x, y) w -> trainCAMNN x y w) nn ioputs

index = 0
camU = CAMUpdate CAMWeigth 0 0

trainCAMNN (input2, output2) 0 camU nn



(g', nn') = trainCAMNNIO (gen, nn) ioputs
(g'', nn'') = trainCAMNNIO (g', nn') ioputs
(g''', nn''') = trainCAMNNIO (g'', nn'') ioputs

applyNeurons neurons input = foldl (\x y -> applyNeuron x y) input neurons
Prelude.map (applyNeurons nn') inputs
Prelude.map (applyNeurons nn'') inputs
Prelude.map (applyNeurons nn''') inputs

--------------------------------

train = input1
desired = output1

query = foldl applyNeuron train nn
lstIndex = 1

deltaWeights' camW0 sel0 sel0 output2
deltaThreshold' camT0 sel0 output0

updateCAMNeuron' camN0 CAMThreshold sel0 output0 output0
updateCAMNeuron' camN0 CAMWeight sel0 input0 input0

applyBackProp output1 input0 input0 camN2

trainNeurons' (trainSet !! 1) (updates !! 1) nn
trainCAMNN' nn updates trainSet
queryCAMNN nn trainSet

--------------------------------

randomInts = take 100 $ randomRs (-100,100) gen
genElem = Prelude.map (\x ->  mkStdGen x) randomInts
Prelude.map (\x -> randomUpdate x nn) genElem

--------------------------------

--------------------------------

applyReverseNeuron compared camN2

camW' = deltaWeights camW0 compared sel0

deltaThreshold camT0 sel0 query0



tr0 = computeS $ traverse2 camW2 query0 const (\f g sh@(Z :. x :. y) -> let nSh = ix1 y in xor (f sh) (g nSh)) :: NNTMU
tr1 = computeS $ traverse2 tr0 output1 const (\f g sh@(Z :. x :. y) -> let nSh = ix1 y in (f sh) ==  (complement $ g nSh)) :: NNTMU
tr2 = computeS $ traverse2 tr1 compared const (\f g sh@(Z :. x :. y) -> let nSh = ix1 y in (f sh) .&. (g nSh)) :: NNTMU


camW' = selectionMethod camW0 query0 query1 compared

camW' = selectionMethod output1 query camW

ll = layerColide camW query xor
layerColide ll output1 (==)

camN' = CAMNeuron camW' camT
nn' = [camN, camN']

query = foldl applyNeuron input1 nn'
compared = vecCompare query output1
hammingDistance compared

--------------------------------

camN = randomCAMNeuron gen 5 4
camW = camWeigths camN
camT = camThresholds camN
gen' = snd $ next gen
input = randomNNTVU gen' 5

camW0 = fromListUnboxed (ix2 2 2) [False, False, False, False]
camT0 = fromListUnboxed (ix1 2) [2,1]
camN0 = CAMNeuron camW0 camT0

camW1 = fromListUnboxed (ix2 2 2) [True, False, True, False]
camT1 = fromListUnboxed (ix1 2) [2,2]
camN1 = CAMNeuron camW1 camT1

input0 = fromListUnboxed (ix1 2) [False, False]
output0 = fromListUnboxed (ix1 2) [False, False]
input1 = fromListUnboxed (ix1 2) [False, True]
output1 = fromListUnboxed (ix1 2) [True, True]
input2 = fromListUnboxed (ix1 2) [True, False]
output2 = fromListUnboxed (ix1 2) [True, True]
input3 = fromListUnboxed (ix1 2) [True, True]
output3 = fromListUnboxed (ix1 2) [False, False]

inputs = [input0, input3, input1, input2]
outputs = [output0, output3, output1, output2]
ioputs = zip inputs outputs
nn = [camN0, camN1]

res0 = applyNeuron input2 camN0
res1 = applyNeuron res0 camN1
res1

applyNeurons neurons input = foldl (\x y -> applyNeuron x y) input neurons
Prelude.map (applyNeurons nn) inputs


--------------------------------
let numElems = 64
let threshold = 1
let trainingDInputR = take 100 $ randomRs (-0.5, 0.5) gen :: [Double]
let trainingDCorrectR = map sin trainingDInputR
let trainingBInput = map doubleToWord trainingDInputR
let trainingBCorrect = map doubleToWord trainingDCorrectR
let (_, gen') = next gen
let testDInput = take numElems $ randomRs (-0.5, 0.5) gen' :: [Double]
let testDCorrect = map sin testDInput
let testBInput = map doubleToWord testDInput
let testBCorrect = map doubleToWord testDCorrect

--------------------------------

let (_, gen) = next gen'
let weigths0 = take numElems $ randoms gen :: [Word64]
let weigths1 = take numElems $ randoms gen :: [Word64]
let weigths2 = take numElems $ randoms gen :: [Word64]

fstElem = trainingBInput !! 0
fstElemCorrect = trainingBCorrect !! 0

let fstCalc = sumBits $ map (xorPCThreshold fstElem threshold) weigths0
let sndCalc = sumBits $ map (xorPCThreshold fstCalc threshold) weigths1
let trdCalc = sumBits $ map (xorPCThreshold sndCalc threshold) weigths2

let deltaCalc = xor trdCalc fstElemCorrect

--------------------------------

-- nn = [camN1, camN2]
index = 0
elemIndex = 1
elemN = CAMThreshold
train = input2
desired = output2

trainCAMNN' (train, desired) (index, elemN, elemIndex) nn

--------------------------------



--------------------------------



--------------------------------



--------------------------------



--***--__---___---___----***--__---___---___---
--***--__---___---___----***--__---___---___---
--***--__---___---___----***--__---___---___---

gen = mkStdGen 2

camW0 = fromListUnboxed (ix2 2 2) [False, False, False, False]
camT0 = fromListUnboxed (ix1 2) [2, 2] :: NTTVU
camN0 = CAMNeuron (CAMWElem camW0 0) (CAMTElem camT0 0)

camW1 = fromListUnboxed (ix2 2 2) [False, False, False, False]
camT1 = fromListUnboxed (ix1 2) [2,1] :: NTTVU
camN1 = CAMNeuron (CAMWElem camW1 0) (CAMTElem camT1 0)

camW2 = fromListUnboxed (ix2 2 2) [True, False, True, False]
camT2 = fromListUnboxed (ix1 2) [2,2] :: NTTVU
camN2 = CAMNeuron (CAMWElem camW2 0) (CAMTElem camT2 0)

sel0 = fromListUnboxed (ix1 2) [True, False]

input0 = fromListUnboxed (ix1 2) [False, False]
output0 = fromListUnboxed (ix1 2) [False, False]
input1 = fromListUnboxed (ix1 2) [False, True]
output1 = fromListUnboxed (ix1 2) [True, True]
input2 = fromListUnboxed (ix1 2) [True, False]
output2 = fromListUnboxed (ix1 2) [True, True]
input3 = fromListUnboxed (ix1 2) [True, True]
output3 = fromListUnboxed (ix1 2) [False, False]

inputs = [input0, input1, input2, input3]
outputs = [output0, output1, output2, output3]
trainSet = P.zipWith (\x y -> TrainElem x y) inputs outputs

nn = [camN0, camN0]
updatesLst = [(1, 0, CAMThreshold), (1, 0, CAMWeight), (0, 1, CAMThreshold), (0, 0, CAMWeight)]
updates = P.map (\(x, y, z) -> CAMUpdate x y z) updatesLst
updates = take (length trainSet) $ constructUpdate' (length nn)

nn' = trainNeurons' (trainSet !! 1) (updates !! 1) nn
nn'' = trainNeurons' (trainSet !! 2) (updates !! 2) nn'

trainCAMNN' nn updates trainSet
trainUntilLearned' nn trainSet 0 3

--***--__---___---___----***--__---___---___---
--***--__---___---___----***--__---___---___---
--***--__---___---___----***--__---___---___---

nSize = 4
testSize = 4
nnSize = 3

camW0 = fromListUnboxed (ix2 nSize nSize) $ replicate (nSize * nSize) False
camT0 = fromListUnboxed (ix1 nSize) $ replicate nSize nSize :: NTTVU
camN0 = CAMNeuron (CAMWElem camW0 0) (CAMTElem camT0 0)

baseLst = [1 .. testSize]
baseOLst = P.map sin [1 .. testSize]
inputsLst = P.map (num2Bin' nSize) baseLst
outputLst = P.map (num2Bin' nSize . round . (* 100)) baseOLst
inputs = P.map (fromListUnboxed (ix1 nSize)) inputsLst
outputs = P.map (fromListUnboxed (ix1 nSize)) outputLst

trainSet = P.zipWith (\x y -> TrainElem x y) inputs outputs

nn = replicate nnSize camN0
updates = take (length trainSet) $ constructUpdate (length nn)

trainNeurons (trainSet !! 0) (updates !! 0) nn

trainUntilLearned nn trainSet 0 3

train = trainInput $ trainSet !! 0
desired = trainOutput $ trainSet !! 0
lIndex = lstIndex $ updates !! 0
cElem = camElem $ updates !! 0

query = foldl applyNeuron train nn
compared = vecCompare query desired
chosenNeuron = nn !! lIndex
choppedNNR = take (lIndex + 1) $ reverse nn
choppedNN = take (lIndex + 1) nn
hidden = foldl applyNeuron train choppedNN
output = applyNeuron hidden chosenNeuron
deltaP = foldl applyReverseNeuron' compared choppedNNR
camNN = updateCAMNeuron' chosenNeuron cElem deltaP output hidden
nn' = replaceElem nn lIndex camNN

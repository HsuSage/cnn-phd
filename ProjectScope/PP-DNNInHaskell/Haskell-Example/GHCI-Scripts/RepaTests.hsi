import qualified Data.Array.Repa                   as RP
import qualified Data.Array.Repa.Algorithms.Matrix as RP
let x = 3 :: InputNodes
let y = 3 :: OutputNodes
let shape = RP.Z RP.:. x RP.:. y
let ssh = RP.Z RP.:. x

let nnBase = NNBase x y y 0.1
nnR <- createNNR nnBase

fLayer <- RP.computeP $ RP.slice (wihR nnR) (RP.Any RP.:. (2::Int)) :: IO NLayerR
let ffLayer = RP.slice (wihR nnR) (RP.Any RP.:. (2::Int))
hLayer <- RP.computeP $ RP.slice (wihR nnR) (RP.Any RP.:. (1::Int)) :: IO NLayerR
oLayer <- RP.computeP $ RP.slice (whoR nnR) (RP.Any RP.:. (0::Int)) :: IO NLayerR

let wihNN = wihR nnR
let whoNN = whoR nnR
let wihNN = RP.fromListUnboxed shape [0..8]
let whoNN = RP.fromListUnboxed shape [9..17]
nnR <- cre

RP.zipWith (*) wihNN fLayer

let x = RP.fromListUnboxed (RP.Z RP.:. (5 :: Int) RP.:. (2 :: Int)) [1..10]
RP.computeP $ RP.reshape (RP.Z RP.:. (2::Int) RP.:. (5::Int)) x :: IO (RP.Array RP.U RP.DIM2 Double)

RP.traverse2 wihNN fLayer (\_ y ->  y) (\f h sh -> h sh)
RP.computeP $ RP.traverse2 wihNN fLayer (\_ y ->  y) (\f h sh -> h sh) :: IO NLayerR


RP.extend (RP.Any RP.:. (3::Int) RP.:. RP.All) fLayer
RP.computeP $ RP.extend (RP.Any RP.:. (3::Int) RP.:. RP.All) fLayer :: IO NNLayer
RP.extend shape fLayer


RP.backpermute shape (\e@(RP.Z RP.:. x RP.:. y) -> RP.Z RP.:. x) fLayer
llk <- RP.computeP $ RP.backpermute shape (\e@(RP.Z RP.:. x RP.:. y) -> RP.Z RP.:. x) fLayer :: IO NNLayerR

RP.extend (RP.Any RP.:. x RP.:. RP.All) fLayer
llp <- RP.computeP $ RP.extend (RP.Any RP.:. x RP.:. RP.All) fLayer :: IO NNLayerR